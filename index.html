<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Hash Functions Taste Great With Anything</title>

		<meta name="description" content="Hash Functions Taste Great with Anything">
		<meta name="author" content="Curtis Lassam">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
		<link rel="stylesheet" href="css/reveal.min.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->

        <style>
            section p{
                color: #15491c;
                size: small;
            }
        </style>
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section data-background="images/1.gif">
                    <p>
                    Hi, I'm Curtis Lassam! 
                    </p>
				</section>
				<section data-background="images/2.gif">
                    <p>
                    I'm a software developer for a University in B.C.
                    </p>
				</section>
				<section data-background="images/3.gif">
                    <p>
                    Not the one you're thinking of.
                    </p>
				</section>
				<section data-background="images/4.gif">
                    <p>
                    The other one.
                    </p>
				</section>
				<section data-background="images/5.gif" data-background-transition="slide">
                    <p>
                    We are going to talk about hash functions.
                    </p>
				</section>
				<section data-background="images/blank.gif">
                    <p>
                    I know what you're thinking. 
                    </p>
				</section>
				<section data-background="images/6.gif"></section>
				<section data-background="images/7.gif"></section>
				<section data-background="images/8.gif"></section>
				<section data-background="images/9.gif"></section>
				<section data-background="images/9.gif">
                    <p>
                    And so on.
                    </p>
                </section>
				<section data-background="images/10.gif" data-background-transition="slide">
                    <p>
                    But I'm going to do my best to show you why this fundamental technique belongs
                    in your toolkit. 
                    </p>
                    <p>
                    You can tell from my drawing of a toolkit: I am not a handy man.
                    </p>
                </section>

                <section data-background="images/blank.gif">
                    <p> We gon' cover </p>
                    <ol>
                        <li> Hash Functions</li>
                        <li> Hash Tables </li>
                        <li> Bloom Filters </li>
                        <li> Choosing the right Hash Function </li>
                        <li> Authentication </li>
                        <li> HMAC </li>
                    </ol>
                </section>


				<section data-background="images/11.gif">
                    <p>
                    You might be thinking: 
                    </p>
                    <p>
                    And you'd be right.
                    </p>
                </section>
				<section data-background="images/12.gif">
                    <p>
                    So for you guys, I've hidden Portland Pete on one slide in
                    this set. If you tell me where he was in the presentation
                    after I'm done, you get a prize. 
                    </p>
                </section>
				<section data-background="images/13.gif">
                    <p>
                    But before you get too excited, the prize is a high five. 
                    </p>
                </section>
				<section data-background="images/14.gif" data-background-transition="slide">
                    <p>
                    Let's get started - what IS a hash function?
                    </p>
                </section>
                <section data-background="images/16.gif">
                    <p>
                    Here's an example. Let's write a function that takes a string
                    </p>
                    <p>
                    splits it into characters
                    </p>
                </section>
                <section data-background="images/17.gif">
                    <p>
                    converts every character into an integer
                    </p>
                </section>
                <section data-background="images/18.gif">
                    <p>
                    adds the integers together
                    </p>
                </section>
                <section data-background="images/19.gif">
                    <p>
                    and mods the result by 100.
                    </p>
                    <p>
                    This is a hash function. 
                    </p>
                    <p>
                    Not every hash function works THIS way, but this - like many
                    other functions, is a hash. 
                    </p>
                    <p>
                    It has a number of useful properties. 
                    </p>
                </section>
                <section data-background="images/20.gif">
                    <p>
                    Regardless of what sequence of characters you put in, 
                    you're guaranteed that the output will be between 
                    0 and 99. 
                    </p>
                </section>
                <section data-background="images/21.gif">
                    <p>
                    The output for a string will always be the same. 
                    </p>
                </section>
                <section data-background="images/22.gif">
                    <p>
                    Many different inputs can produce the same output. 
                    </p>
                </section>
                <section data-background="images/23.gif">
                    <p>
                    And given the output, it's impossible to guess the input that produced it.  
                    </p>
                </section>
                <section data-background="images/15.gif" data-background-transition="slide">
                    <p>
                    I know, I know, invoking the wikipedia definition of something
                    is the presentation equivalent to opening a speech with 
                    "Webster's Dictionary Defines", but it's a good definition. 
                    </p>
                </section>
                <section data-background="images/24.gif" data-background-transition="slide">
                    <p>
                    So, that's a hash function - now let's talk about Hash Tables. 
                    </p>
                </section>
                <section data-background="images/25.gif">
                    <p>
                    Hash tables are a data structure concept used to store keys
                    and values. 
                    </p>
                    <p>
                    Keys and values are important - you deal with them when you
                    work with things like 
                    </p>
                </section>
                <section data-background="images/26.gif"></section>
                <section data-background="images/28.gif"></section>
                <section data-background="images/29.gif">
                    <p>  or Javascript objects </p>
                </section>
                <section data-background="images/30.gif">
                    <p> And if you're dealing with keys and values, chances are, 
                        behind the scenes, something clever with hash tables
                        is happening. </p>
                    <p> It could be something else, like a tree or a trie, 
                        but those aren't what we're talking about right now,
                        so I'm going to pretend that they don't exist. </p>
                </section>
                <section data-background="images/31.gif">
                    <p> So let's start with a big block of memory - let's say
                        an array with 100 elements. </p> 
                </section>
                <section data-background="images/32.gif">
                    <p> 
                        We want to store the value "hash two one five dee two nine" 
                        against the key "color". 
                    </p> 
                </section>
                <section data-background="images/33.gif">
                    <p> 
                        So we run a hash function on the key, "color"
                    </p> 
                </section>
                <section data-background="images/34.gif">
                    <p> 
                        this produces a number
                    </p> 
                </section>
                <section data-background="images/35.gif">
                    <p> 
                        which we mod by the length of our table.
                    </p> 
                </section>
                <section data-background="images/36.gif">
                    <p> 
                        this gives us an index. 
                    </p> 
                </section>
                <section data-background="images/37.gif">
                    <p> 
                        and then we can just store our value at the 
                        location pointed to by the index. 
                    </p> 
                    <p> That's a hash table. Easy peasy. </p> 
                </section>
                <section data-background="images/37b.gif"></section>
                <section data-background="images/37c.gif">
                    <p>
                    This has a lot of really positive qualities. 
                    </p>
                    <p> Insert? Constant time. </p>
                    <p> Delete? Constant time. </p>
                    <p> Lookup? Constant time. </p> 
                    <p> Search? Uuuuh. Don't search a hash table. </p> 
                </section>
                <!-- 2:30 -->
                <section data-background="images/38.gif">
                    <p> 
                        But it is not quite so easy, nor quite so peasy. 
                    </p> 
                </section>
                <section data-background="images/39.gif">
                    <p> 
                        As the array fills up with values, 
                    </p> 
                </section>
                <section data-background="images/41.gif">
                    <p> 
                        it gets more and more likely that we'll have a hash
                        value point to a spot in the array that's already full.
                    </p> 
                </section>
                <section data-background="images/42.gif">
                    <p> 
                        This is called a "collision".
                    </p> 
                </section>
                <section data-background="images/43.gif">
                    <p> 
                        What do we do when there's already a value 
                        in the spot where we want to store a value?
                    </p> 
                </section>
                <section data-background="images/44.gif">
                    <p> 
                        We can keep walking forward in the table until 
                        we find an available spot. 
                    </p> 
                </section>
                <section data-background="images/45.gif">
                    <p> 
                        This is called 'linear probing'.
                    </p> 
                </section>
                <section data-background="images/47.gif">
                    <p> 
                        Alternatively, we could root a linked list at every 
                        space in the
                        array. That way, our hash table can take as many
                        values as we can throw at it. 
                    </p>
                </section>
                <section data-background="images/47b.gif">
                    <p> 
                        Or a tree. We could also root a tree at every 
                        space in the table. 
                    </p>
                </section>
                <section data-background="images/48.gif">
                    <p> 
                        This - rooting a separate data structure at every 
                        spot in the table - is called a 'chained hash table'.
                    </p> 
                </section>
                <section data-background="images/49.gif">
                    <p> 
                        One problem: 
                    </p>
                    <p>
                        Here, there's a bunch of different values
                        stored where we're looking for the key, "cheese".
                    </p>
                    <p>
                        How do we know which is the right one?
                    </p> 
                </section>
                <section data-background="images/50.gif">
                    <p> 
                        We need to store the key with the value, so 
                        that we can make sure we're retrieving the right thing.
                    </p> 
                    <p>
                        This is going to be the case any time we have to 
                        deal with collision - if we can retrieve multiple 
                        values from our hash table, we need to be able to
                        tell which is the correct one.
                    </p>
                </section>
                <section data-background="images/51.gif">
                    <p> 
                        Even with some strategy for collision detection in place,
                        it's possible for the table to get so full that it
                        performs very sluggishly.
                    </p>
                    <p>
                        A crowded chained-hash is little better than a linked list.
                    </p> 
                </section>
                <section data-background="images/52.gif">
                    <p> 
                        or - in the case of
                        hashing strategies that just shuffle addresses around -
                        it's possible for the table to become completely full. 
                    </p> 
                </section>
                <section data-background="images/52a.gif">
                    <p> 
                        When this happens, it's time to rebuild the hash. 
                    </p> 
                </section>
                <section data-background="images/53.gif">
                    <p> 
                        This is the time-consuming process of addressing an
                        even bigger whack of memory, 
                    </p> 
                </section>
                <section data-background="images/54.gif">
                    <p> 
                        Taking all of the keys out of the first array,
                        re-hashing them, and putting them in the second array.
                    </p> 
                </section>
                <section data-background="images/blank.gif">
                    <p> 
                        There's one language I can think of, whose default
                        HashTable implementation can perform this 
                        computationally intensive rebuild step unexpectedly 
                        any time an insert pushes the table above a 
                        pre-defined load limit. 
                    </p> 
                </section>
                <section data-background="images/55.gif" data-background-transition="slide">
                </section>
                <section data-background="images/blank.gif">
                    <p> 
                        But for the sake of politeness I'm not going to mention which language.
                    </p> 
                    <p>
                        Of course, linear probing and chained hashing are not the
                        only hash table management strategies - 
                        There are many, many hashing strategies. 
                    </p>
                </section>
                <section data-background="images/56.gif">
                    <p> 
                        Like robin-hood hashing
                    </p> 
                </section>
                <section data-background="images/57.gif">
                    <p> 
                        which steals data from your richer tables
                    </p> 
                </section>
                <section data-background="images/58.gif">
                    <p> 
                        and inserts it to your poorer tables.
                    </p> 
                </section>
                <section data-background="images/59.gif">
                    <p> 
                        Or hopscotch hashing, 
                    </p> 
                </section>
                <section data-background="images/60.gif">
                    <p> 
                        where you implement the entire
                        array in chalk, on the pavement. 
                    </p> 
                </section>
                <section data-background="images/blank.gif">
                    <p>
                        I am definitely right about those last two.
                        No need to check them on the internet or anything. 
                    </p>
                </section>
                <section data-background="images/60b.gif"><p></p></section>
                <!-- 5:00 --> 
                <section data-background="images/61.gif" data-background-transition="slide">
                    <p>
                    Okay, so, that first 5 minutes of the presentation was there
                    to get you up to speed on the basics. Now let's get to some
                    of the meat!
                    </p> 
                </section>
                <section data-background="images/62.gif">
                    <p> 
                    A bloom filter is a great way to keep balloons out of your face. 
                    </p> 
                    <p>
                    I'm not sure how this slide ended up in here. 
                    </p>
                </section>
                <section data-background="images/63.gif">
                    <p> 
                        A bloom filter is a data structure that's fast
                    </p> 
                </section>
                <section data-background="images/64.gif">
                    <p> 
                        and space efficient
                    </p> 
                </section>
                <section data-background="images/65.gif">
                    <p> 
                        used to test for membership in a set.
                    </p> 
                </section>
                <section data-background="images/66.gif">
                    <p> 
                    That's important - it tests for set membership, 
                    it doesn't store any data. 
                    </p>
                    <p>
                    It can tell you if something is in a set,
                    but you can't retrieve an item
                    from the set. 
                    </p> 
                </section>
                <section data-background="images/67.gif">
                    <p> 
                    Like, if we have three objects - banana, apple, and bowling ball. 
                    </p> 
                </section>
                <section data-background="images/68.gif">
                    <p> 
                    And a bloom filter, representing the set of 'fruit'. 
                    </p> 
                </section>
                <section data-background="images/69.gif">
                    <p> 
                    We can use the set to determine that banana and apple are 'fruit', and 'bowling ball' is not. 
                    </p> 
                </section>
                <section data-background="images/69b.gif">
                    <p> 
                    But we can't give you a list of all of the fruit that were
                    used to populate the set. 
                    </p> 
                    <p> We don't know them. </p>
                </section>
                <section data-background="images/70.gif">
                    <p> 
                    So, a lot of the time, Bloom Filters are used to answer questions like
                    </p> 
                </section>
                <section data-background="images/71.gif"></section>
                <section data-background="images/72.gif"></section>
                <section data-background="images/72b.gif"></section>
                <section data-background="images/72c.gif">
                    <p> 
                    Okay, let's look at this image problem a little bit.
                    </p>
                    <p> 
                    Let's imagine we're running a forum and our itinerant
                    users keep posting the same images again and again. 
                    There's gigabytes of the same few hundred images, 
                    over and over and over. 
                    </p>
                    <p>
                    We want to detect when the user is sending us a 
                    repeat image, and instead, just use an image link
                    that already exists. 
                    </p>
                </section>
                <section data-background="images/76.gif">
                    <p>
                    let's say we run a hash function on the target image,
                    </p>
                    <p> 
                    yes, you can hash images - you can hash most anything
                    </p>
                </section>
                <section data-background="images/77.gif">
                    <p>
                    mod the result by the length of an array
                    </p>
                </section>
                <section data-background="images/78.gif">
                    <p>
                    move to that index location in the array
                    </p>
                </section>
                <section data-background="images/79.gif">
                    <p>
                    and save a link to the image there.
                    </p>
                    <p>
                    Then, when we're checking a new image, we can hash it, 
                    and then check to see if it's in our array. 
                    </p>
                </section>
                <section data-background="images/83.gif">
                    <p>
                    of course, this is just a bog-standard hash table, 
                    and I'm supposed to be talking about Bloom Filters
                    </p>
                </section>
                <section data-background="images/79.gif">
                    <p>
                    this works fine, but it takes up a lot of space
                    </p>
                    <p>
                    and I promised you space efficiency
                    </p>
                </section>
                <section data-background="images/72c.gif">
                    <p>
                        Let's imagine there are 5000 images we want to 
                        keep out of our forums and they take up 100 kilobytes each.
                    </p>
                    <p>
                        That means about a 500 megabyte table of duplicate images.
                        While it's not a tonne of space, it's enough that 
                        you probably won't want to keep the whole thing
                        in RAM.
                    </p>

                </section>
                <section data-background="images/79.gif">
                    <p>
                    remember, though, that we don't need storage from our
                    data structure</p>
                    <p>
                    we're only interested in whether or not this image <em>exists</em>
                    </p>
                </section>
                <section data-background="images/84.gif">
                    <p>
                    let's imagine that we store zeroes in every space in our
                    table
                    </p>
                </section>
                <section data-background="images/85.gif">
                    <p>
                    and we store ones where our hash functions land.
                    </p>
                </section>
                <section data-background="images/86.gif">
                    <p>
                    that way, we can check if an image is banned
                    </p>
                </section>
                <section data-background="images/87.gif">
                    <p>
                    by hashing it, modding it
                    </p>
                </section>
                <section data-background="images/88.gif">
                    <p>
                    and then checking if that spot in the array has 
                    a 1 in it. 
                    </p>
                </section>
                <section data-background="images/89.gif">
                    <p>
                    if there's no 1 there, we can't possibly have
                    seen that image before. 
                    </p>
                </section>
                <section data-background="images/90.gif">
                    <p>
                    there's only one slight problem with this technique. 
                    </p>
                    <p>
                    what happens when we have a different image that accidentally
                    collides with an image that we've set earlier?
                    </p>
                </section>
                <section data-background="images/91.gif">
                    <p>
                    this creates a false positive, and unfairly takes
                    pictures of Nicholas Cage out of circulation
                    </p>
                </section>

                <section data-background="images/blank.gif">
                    <p>
                    How do we stop collisions like this from occurring? 
                    </p>
                    <p>
                    Well, we can use a hash function that guarantees an
                    astronomically low probability of collision. 
                    </p>
                </section>
                <section data-background="images/92.gif">
                    <p>
                    MD5, for example. 
                    </p>
                    <p>
                    is a hash function that guarantees and 
                    astronomically low probability of collision
                    </p>
                </section>
                <section data-background="images/blank.gif">
                    <p>
                    But, with the astronomically low probability of collision, 
                    you get, axiomatically, an astronomically high number of
                    potential outputs. With one bit for every output, you're
                    suddenly saddled with 
                    </p>
                </section>
                <section data-background="images/93.gif">
                    <p>
                    four times ten to the 25 terabytes, which is just a little
                    bit unrealistic to implement as a bit array. 
                    </p>
                </section>
                <section data-background="images/94.gif">
                    <p> it does hit on one of the two strategies we can use
                    to reduce collisions, though </p>
                </section>
                <section data-background="images/95.gif">
                    <p>
                    the obvious one: more space.
                    </p>
                    <p> 
                    now let's look at the less obvious one:
                    </p>
                </section>
                <section data-background="images/96.gif">
                    <p>
                    more hash functions.
                    </p> 
                </section>
                <section data-background="images/97.gif">
                    <p>
                    instead of hashing our image just once, let's hash it twice,
                    with two different hash functions
                    </p>
                </section>
                <section data-background="images/98.gif">
                    <p>
                    this gives us two different locations in the table, and
                    we can store a one at both of them 
                    </p>
                </section>
                <section data-background="images/99.gif">
                    <p>
                    another image
                    </p>
                </section>
                <section data-background="images/100.gif">
                    <p>
                    might share the result of one of
                    the hash functions
                    </p>
                </section>
                <section data-background="images/101.gif">
                    <p>
                    but it's not as likely to share
                    the result of all of them
                    </p>
                    <p>
                    and if any of the hash functions point to a location
                    with a zero in it, we know that this object can never
                    have been entered into the Bloom Filter
                    </p>
                </section>
                <section data-background="images/102.gif">
                    <p>
                    So, this is a bloom filter. 
                    </p>
                    <p>
                    A bit field, and multiple hash functions to set the bits
                    in that field. 
                    </p>
                    <p>
                    We put items in by hashing them multiple times and setting
                    the bits at all of those locations</p>
                    <p>
                    And we check if items are in the set by hashing items
                    multiple times
                    and checking if the bits are set at all of those locations. 
                </section>
                <section data-background="images/blank.gif">
                    <p>
                    There are some downsides to this. 
                    </p>
                </section>
                <section data-background="images/103.gif">
                    <p>
                    <br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>
                    <br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>
                    Because each item we put in to the Bloom Filter
                    has multiple hash functions, and there can be 
                    some overlap, we can never delete anything from 
                    the Bloom Filter
                    </p>
                </section>
                <section data-background="images/104.gif">
                    <p>
                    <br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>
                    <br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>
                    if we do
                    </p>
                </section>
                <section data-background="images/105.gif">
                    <p>
                    <br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>
                    <br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>
                    we run the risk
                    of accidentally deleting something else from the filter. 
                    </p>
                </section>
                <section data-background="images/blank.gif">
                    <p>
                    on top of that, we've reduced the chance of collisions, 
                    but it's impractical to reduce that chance to effectively
                    zero, so there's always some chance of a false positive. 
                    </p>
                    <p>
                    however, this probability is at least a number that we
                    have control over
                    </p>
                </section>
                <section data-background="images/106.gif">
                    <p> 
                    if we know the desired probability of a collision
                    </p>
                </section>
                <section data-background="images/107.gif">
                    <p>
                     - in the case of our image filter, let's say 0.1%.
                    </p>
                </section>
                <section data-background="images/108.gif">
                    <p>
                    and the number of things we want to put in the filter
                    </p>
                </section>
                <section data-background="images/109.gif">
                    <p>
                     as we mentioned before, about 5000 images
                    </p>
                </section>
                <section data-background="images/111.gif">
                    <p>
                    we can use handwavy math to determine
                    how much space we need 
                    </p>
                    <p>
                    and how many hash functions we need
                    </p>
                    <p>
                    to get an optimal solution
                    </p>
                </section>
                <section data-background="images/112.gif">
                    <p> 
                    so, we need an array of 71,888 bits - 8.8 kilobytes
                    </p>
                    <p>
                    that's small enough that we could keep it in RAM - heck
                    we could send that bloom filter to the user and run
                    it client-side. It's certainly easier to work with
                    than 500 megabytes of image.</p> 
                </section>
                <section data-background="images/113.gif">
                    <p>
                    and 10 different hash functions.
                    </p>
                </section>
                <section data-background="images/114.gif">
                    <p>
                    A lot of the time, Bloom Filters are paired up with other
                    data structures that handle the storage of the items.
                    </p>
                    <p>
                    For example, they are useful when paired with data structures 
                    that exhibit worst-case performance
                    when searching for items that are not in the data-structure.
                    </p>
                    <p>
                    In a linked list, or unsorted large array, for example, you
                    get the worst possible case performance when you're searching
                    for an item that just isn't there. 
                    </p>
                    <p>
                    The bloom filter can check, before you hit the data structure,
                    if the data is in there.
                    </p>
                </section>
                <section data-background="images/115.gif">
                    <p>
                    they are also very useful
                    when the retrieval step for data takes a long time - for 
                    example, when a network call needs to be made to a far
                    away database, a local bloom filter is a wonderfully 
                    fast way to know if you are wasting everybody's time with
                    a request for something that doesn't exist. 
                    </p>
                </section>
                <section data-background="images/116.gif">
                    <p>
                    or, data with a very low hit rate - if you're dealing 
                    with the sort of data where you're getting 10 misses 
                    for every hit, you can catch all of those misses 
                    with a bloom filter.
                    </p>
                </section>
                <section data-background="images/117.gif">
                    <p>
                    Google Chrome does this - 
                    </p>
                </section>
                <section data-background="images/118.gif">
                    <p>
                    when checking if a URL is malicious, 
                    it maintains a small, fast, local Bloom Filter seeded with
                    malicious URLs. If the Bloom Filter flags a URL as a possible
                    match, 
                </section>
                <section data-background="images/119.gif">
                    <p>
                    only then will Chrome make the milliseconds-long round-trip 
                    to their servers to check the details. 
                    </p>
                    <p> This use case matches up pretty well with our list of 
                    times when a bloom filter is useful - a call to a remote
                    server takes a huge amount of time compared to running 
                    a few hash functions, and maybe only one in 100 websites
                    you visit will actually be a hit
                    </p>
                </section>    
                <section data-background="images/120.gif">
                </section>

                <section data-background="images/121.gif">
                    <p>
                    Let's talk about how to pick which hash functions to use. 
                    </p>
                </section>
                <section data-background="images/122.gif">
                    <p>
                    I mean, I showed you my awesome cheesehash function earlier, but
                    its terrible, and on top of that it only really works on
                    strings. 
                    </p>
                </section>
                <section data-background="images/123.gif">
                    <p>
                    Now, the number of different Hash Functions are countless - 
                    each one a unique snowflake.
                    </p>
                    <p>
                    only three of these are made-up
                    </p>
                </section>
                <section data-background="images/124.gif">
                    <p>
                    So which ones do we pick for our data structures? 
                    </p>
                </section>
                <section data-background="images/125.gif">
                    <p> 
                    well, for data-structures, the two properties we're
                    looking for in a hash are that the hash should
                    be fast, and well-distributed
                    </p>
                </section>
                <section data-background="images/126.gif">
                    <p>
                    When we say 'fast', what we mean is 'non-cryptographic'.
                    </p>
                </section>
                <section data-background="images/128.gif">
                    <p>
                    Cryptographic hashes are awesome. They have a bunch of 
                    properties that make them totally bad-ass for security 
                    functionality. 
                    </p>
                </section>
                <section data-background="images/129.gif">
                    <p>
                    The most important one being that they're "collision resistant" - 
                    it's astronomically unlikely that you will be able to find
                    two different items that hash to the same value. 
                    </p>
                </section>
                <section data-background="images/130.gif">
                    <p>
                    But these cryptographic features also make them a lot more 
                    processor-hungry.
                    </p>
                    <p>
                    So we should avoid hashes like SHA or MD5 when
                    we're working on data structure stuff, because we don't 
                    need awesome security features in our Bloom Filter.  
                    It's just a waste of CPU cycles. 
                    </p>
                </section>
                <section data-background="images/126.gif">
                    <p>So, non-cryptographic.</p>
                </section>
                <section data-background="images/131.gif">
                    <p>
                    And well-distributed, which means that no matter how
                    similar your data <em>is</em> going in to the hash function,
                </section>
                <section data-background="images/132.gif">
                    <p>
                    the
                    output appears all over the spectrum. 
                    </p>
                </section>
                <section data-background="images/133.gif">
                    <p> Hash functions that exhibit this quality are known
                    as 'avalanching' hashes
                    </p>
                </section>
                <section data-background="images/134.gif">
                    <p>
                    because small changes in the input 
                    </p>
                </section>
                <section data-background="images/135.gif">
                    <p>
                    lead to large changes in the output. 
                    </p>
                    <p> 
                    Of course, this is also a desirable property in 
                    cryptographic hashes, but this one we're willing to blow
                    our precious processor time on, because it's really important
                    in most data structures that depend on hash functions. 
                    </p>
                </section>
                <section data-background="images/136.gif">
                    <p>
                    A common hash used for this purpose is the 
                    non-cryptographic, well-avalanching, 
                    public domain Murmur3 - implementations of which exist 
                    for most modern languages
                    </p>
                </section>
                <section data-background="images/137.gif">
                    <p>
                    - and which has appeared in numerous open-source products, including Hadoop, 
                    Cassandra, and nginx. 
                    </p>
                </section>
                <section data-background="images/138.gif">
                    <p>
                    It also takes a seed value, so you can create dozens of different hash functions
                    out of Murmur3
                    </p>
                </section>
                <section data-background="images/139.gif">
                    <p>
                    just by changing the seed value. 
                    </p>
                </section>
                <section data-background="images/140.gif">
                    <p>
                    There are about five different implementations of it in NPM
                    </p>
                </section>
                <section data-background="images/80.gif">
                    <p>
                    One other thing - we hashed an image to put in our data structure. 
                    </p>
                    <p>
                    What sort of hash function works on an image?
                    </p>
                </section>
                <section data-background="images/141.gif">
                    <p>
                    Well, most of them, really, but a perceptual hash, or
                    pHash, is designed specifically to cluster very similar
                    images together in the hash output.  
                    </p>
                </section>
                <section data-background="images/142.gif">
                    <div style="margin-left:350px">
                        <p>
                        For example, if it's the same image, but sized larger,
                        or skewed to the left, it should end up with a hash
                        location very close to or identical to the hash location
                        of the original image.
                        </p>
                        <p>
                        Of course, by nature, this hash function won't be 
                        distributed in the way that we would need for
                        an optimal general-purpose data structure
                        </p>
                        <p>
                        It's the opposite of an 'avalanching' hash - small changes
                        in the input lead to almost no changes in the output.
                        </p>
                        <p>
                        But we can abuse that property so that false positives are
                        unfairly clustered on images that look very similar to
                        our banned images.
                        Which would actually probably be a good thing.
                        </p>
                    </div>
                </section>
                <section data-background="images/143.gif">
                    <p>
                    You can try it out with a npm install phash
                    </p>
                </section>

                <!-- security --> 
                
                <!-- (not MD5:bozocrack) --> 
                <section data-background="images/blank.gif"></section>
			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: 'none', // default/cube/page/concave/zoom/linear/fade/none

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
				]
			});

		</script>

	</body>
</html>
