<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Hash Functions Taste Great With Anything</title>

		<meta name="description" content="Hash Functions Taste Great with Anything">
		<meta name="author" content="Curtis Lassam">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
		<link rel="stylesheet" href="css/reveal.min.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->

        <style>
            section > div{
                color: white;
                font-weight: bold;
                font-family: "Helvetica", Arial, sans-serif !important;
                font-size: x-large !important;
                background-color: #111;
                /*color: #15491c;
                size: small !important;
                */
                margin-top:650px !important;
                width: 1000px !important;

            }
            section p{
                margin-bottom: 3px !important;
                padding-top: 1px;
            }
        </style>
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section data-background="images/1a.gif" data-background-transition="slide">
				</section>
				<section data-background="images/nameplate_2.gif">
                    <div>
                    <p> Hi, I'm Curtis Lassam. </p>
                    <p> (That's classam on twitter) </p>
                    <p> I've probably left my phone on, so let's play a game where every time
                    I say something stupid or AMAZING, you make my pockets light up. </p>
                    </div>
				</section>
				<section data-background="images/nameplate_2.gif">
                    <div>
                    <p> You'll notice that everything I say is appearing under my slides in
                        black and white text. </p>
                    <p> The first time I did a presentation this way, I made it a really hard to
                        read font, to hide the fact that I'm cheating, by including my presentation notes
                        right on the presentation. </p>
                    </div>
				</section>
				<section data-background="images/nameplate_2.gif">
                    <div>
                    <p> But then I attended a conference that asked for my presentation notes
                        so that they could do closed captioning for the hearing impaired and
                        that seemed like such a cool idea that I decided that I'd
                        amp up the visibility of my own notes, so that it would be easier to read
                        what I'm saying. It makes my online slides way more legible, too, so win-win.</p>
                    </div>
				</section>
				<section data-background="images/nameplate_2.gif">
                    <div>
                    <p>
                    My glorious overlords at Sauce Labs are the reason that
                    I don't have to burn Paid Time Off in order to give this presentation,
                    so take a few seconds to soak in their generosity.
                    </p>
                    </div>
				</section>
				<section data-background="images/10.gif" data-background-transition="slide">
                    <div>
                    <p> Hash functions! </p>
                    <p>
                    I'm going to do my best to show you why this fundamental technique belongs
                    in your toolkit.
                    </p>
                    <p>
                    You can tell from my drawing of a toolkit: I am not a handy man.
                    </p>
                </div>
                </section>

                <section data-background="images/toc.gif">
                    <div>
                    <p>So, we're going to talk about hash functions, hash tables,
                        bloom filters, choosing hash functions, and hashes in security. </p>
                    </div>
                </section>

				<section data-background="images/11.gif" data-background-transition="slide">
                    <div>
                    <p>
                    Let's get started - what IS a hash function?
                    </p>
                </div>
                </section>
				<section data-background="images/crusher.gif" data-background-transition="slide">
                    <div>
                    <p>
                    Well, a hash function is a function that takes arbitrary input, for example, any string -
                    and produces an output that is constrained - for example, an integer from 0 to 99.
                    </p>
                </div>
                </section>
                <section data-background="images/16.gif">
                    <div>
                    <p>
                    Here's an example. Let's write a function that takes a string
                    </p>
                    <p>
                    splits it into characters
                    </p>
                </div>
                </section>
                <section data-background="images/17.gif">
                    <div>
                    <p>
                    converts every character into an integer
                    </p>
                </div>
                </section>
                <section data-background="images/18.gif">
                    <div>
                    <p>
                    adds the integers together
                    </p>
                </div>
                </section>
                <section data-background="images/19.gif">
                    <div>
                    <p>
                    and mods the result by 100.
                    </p>
                    <p>
                    This is a hash function.
                    </p>
                </div>
                </section>
                <section data-background="images/19.gif">
                    <div>
                    <p>
                    Not every hash function works THIS way, but this - like any other function
                    that takes an arbitrary input and produces a constrained output, is a hash.
                    </p>
                    <p>
                    It has a number of useful properties.
                    </p>
                </div>
                </section>
                <section data-background="images/20.gif">
                    <div>
                    <p>
                    Regardless of what sequence of characters you put in,
                    you're guaranteed that the output will be of a fixed range - in this case,
                    between 0 and 99.
                    </p>
                </div>
                </section>
                <section data-background="images/21.gif">
                    <div>
                    <p>
                    The output for a string will always be the same.
                    </p>
                    <p>
                    No matter how many times we throw the word 'wings' at our cheese hash function,
                    the value that it produces will always be 52.
                    </p>
                </div>
                </section>
                <section data-background="images/22.gif">
                    <div>
                    <p>
                    Many different inputs can produce the same output.
                    </p>
                </div>
                </section>
                <section data-background="images/23.gif">
                    <div>
                    <p>
                    Usually, given the output, it's not easy to guess the input that produced it.
                    </p>
                </div>
                </section>
                <section data-background="images/15.gif" data-background-transition="slide">
                    <div>
                    <p>
                    So - a hash function is any algorithm that maps data of arbitrary length to data
                    of a fixed length - so, no matter what sort of data you put in, you always
                    get a variable within a certain range.
                    </p>
                </div>
                </section>
                <section data-background="images/24.gif" data-background-transition="slide">
                    <div>
                    <p>
                    So, that's a hash function - now let's talk about Hash Tables.
                    </p>
                </div>
                </section>
                <section data-background="images/25.gif">
                    <div>
                    <p>
                    Hash tables are a data structure concept used to store keys
                    and values.
                    </p>
                    <p>
                    Keys and values are important - you deal with them when you
                    work with things like
                    </p>
                </div>
                </section>
                <section data-background="images/26.gif">
                    <div>
                    <p>
                    MongoDB
                    </p>
                </div>
                </section>
                <section data-background="images/28.gif">
                    <div>
                    <p>
                    Memcached
                    </p>
                </div>
                </section>
                <section data-background="images/29.gif">
                    <div>
                    <p> or Python dicts</p>
                </div>
                </section>
                <section data-background="images/25.gif">
                    <div>
                    <p> And if you're dealing with keys and values, chances are,
                        behind the scenes, something clever with hash tables
                        is happening. </p>
                    <p> It could be something else, like a tree or a trie,
                        but those aren't what we're talking about right now,
                        so I'm going to pretend that they don't exist. </p>
                    </div>
                </section>
                <section data-background="images/31.gif">
                    <div>
                    <p> So let's start with a big block of memory - let's say
                        an array with 100 elements. </p>
                    </div>
                </section>
                <section data-background="images/32.gif">
                    <div>
                    <p>
                        We want to store the value "hash two one five dee two nine"
                        against the key "color".
                    </p>
                </div>
                </section>
                <section data-background="images/33.gif">
                    <div>
                    <p>
                        So we run a hash function on the key, "color"
                    </p>
                </div>
                </section>
                <section data-background="images/34.gif">
                    <div>
                    <p>
                        this produces a number
                    </p>
                </div>
                </section>
                <section data-background="images/35.gif">
                    <div>
                    <p>
                        which we mod by the length of our table.
                    </p>
                </div>
                </section>
                <section data-background="images/36.gif">
                    <div>
                    <p>
                        this gives us an index.
                    </p>
                </div>
                </section>
                <section data-background="images/37.gif">
                    <div>
                    <p>
                        and then we can just store our value at the
                        location pointed to by the index.
                    </p>
                    <p> That's a hash table. Easy peasy. </p>
                </div>
                </section>
                <!-- 2:30 -->
                <section data-background="images/blank.gif">
                    <div>
                    <p>
                        But it is not quite so easy, nor quite so peasy.
                    </p>
                </div>
                </section>
                <section data-background="images/39.gif">
                    <div>
                    <p>
                        As the array fills up with values,
                    </p>
                </div>
                </section>
                <section data-background="images/41.gif">
                    <div>
                    <p>
                        it gets more and more likely that we'll have a hash
                        value point to a spot in the array that's already full.
                    </p>
                </div>
                </section>
                <section data-background="images/42.gif">
                    <div>
                    <p>
                        This is called a "collision".
                    </p>
                </div>
                </section>
                <section data-background="images/43.gif">
                    <div>
                    <p>
                        What do we do when there's already a value
                        in the spot where we want to store a value?
                    </p>
                </div>
                </section>
                <section data-background="images/44.gif">
                    <div>
                    <p>
                        We can keep walking forward in the table until
                        we find an available spot.
                    </p>
                </div>
                </section>
                <section data-background="images/45.gif">
                    <div>
                    <p>
                        This is called 'linear probing'.
                    </p>
                </div>
                </section>
                <section data-background="images/47.gif">
                    <div>
                    <p>
                        Alternatively, we could root a linked list at every
                        space in the
                        array. That way, our hash table can take as many
                        values as we can throw at it.
                    </p>
                </div>
                </section>
                <section data-background="images/47b.gif">
                    <div>
                    <p>
                        Or a tree. We could also root a tree at every
                        space in the table.
                    </p>
                </div>
                </section>
                <section data-background="images/48.gif">
                    <div>
                    <p>
                        This - rooting a separate data structure at every
                        spot in the table - is called a 'chained hash table'.
                    </p>
                </div>
                </section>
                <section data-background="images/49.gif">
                    <div>
                    <p>
                        One problem:
                    </p>
                    <p>
                        Here, there's a bunch of different values
                        stored where we're looking for the key, "cheese".
                    </p>
                    <p>
                        How do we know which is the right one?
                    </p>
                </div>
                </section>
                <section data-background="images/50.gif">
                    <div>
                    <p>
                        We need to store the key with the value, so
                        that we can make sure we're retrieving the right thing.
                    </p>
                    <p>
                        This is going to be the case any time we have to
                        deal with collision - if we can retrieve multiple
                        values from our hash table, we need to be able to
                        tell which is the correct one.
                    </p>
                </div>
                </section>
                <section data-background="images/51.gif">
                    <div>
                    <p>
                        Even with some strategy for collision detection in place,
                        it's possible for the table to get so full that it
                        performs very sluggishly.
                    </p>
                    <p>
                        A crowded chained-hash is little better than a linked list.
                    </p>
                </div>
                </section>
                <section data-background="images/52.gif">
                    <div>
                    <p>
                        or - in the case of
                        hashing strategies that just shuffle addresses around -
                        it's possible for the table to become completely full.
                    </p>
                </div>
                </section>
                <section data-background="images/52a.gif">
                    <div>
                    <p>
                        When this happens, it's time to rebuild the hash.
                    </p>
                </div>
                </section>
                <section data-background="images/53.gif">
                    <div>
                    <p>
                        This is the time-consuming process of addressing an
                        even bigger whack of memory,
                    </p>
                </div>
                </section>
                <section data-background="images/54.gif">
                    <div>
                    <p>
                        Taking all of the keys out of the first array,
                        re-hashing them, and putting them in the second array.
                    </p>
                </div>
                </section>
                <section data-background="images/blank.gif">
                    <div>
                    <p>
                        Of course, linear probing and chained hashing are not the
                        only hash table management strategies -
                        There are many, many ways to manage a hash table.
                    </p>
                </div>
                </section>
                <section data-background="images/56.gif">
                    <div>
                    <p>
                        Like robin-hood hashing
                    </p>
                </div>
                </section>
                <section data-background="images/57.gif">
                    <div>
                    <p>
                        which steals data from your richer tables
                    </p>
                </div>
                </section>
                <section data-background="images/58.gif">
                    <div>
                    <p>
                        and inserts it to your poorer tables.
                    </p>
                </div>
                </section>
                <section data-background="images/59.gif">
                    <div>
                    <p>
                        Or hopscotch hashing,
                    </p>
                </div>
                </section>
                <section data-background="images/60.gif">
                    <div>
                    <p>
                        where you implement the entire
                        array in chalk, on the pavement.
                    </p>
                    <p>
                        You probably shouldn't fact check me
                        on those last two things.
                    </p>
                </div>
                </section>
                <section data-background="images/37b.gif"></section>
                <section data-background="images/37c.gif">
                    <div>
                    <p> Insert? Constant time. </p>
                    <p> Delete? Constant time. </p>
                    <p> Lookup? Constant time. </p>
                    <p> Search? Uuuuh. Don't search a hash table. </p>
                </div>
                </section>
                <section data-background="images/61.gif" data-background-transition="slide">
                    <div>
                    <p>
                    Okay, so, that first few minutes of the presentation was there
                    to get you up to speed on the basics. Now let's get to some
                    of the meat!
                    </p>
                    <p>Bloom filters.</p>
                </div>
                </section>
                <section data-background="images/balloons.gif">
                    <div>
                    <p>
                    A bloom filter is a great way to keep balloons out of your face.
                    </p>


                </div>
                </section>
                <section data-background="images/63.gif">
                    <div>
                    <p>
                        A bloom filter is a data structure that's fast
                    </p>
                </div>
                </section>
                <section data-background="images/64.gif">
                    <div>
                    <p>
                        and space efficient
                    </p>
                </div>
                </section>
                <section data-background="images/65.gif">
                    <div>
                    <p>
                        used to test for membership in a set.
                    </p>
                </div>
                </section>
                <section data-background="images/66.gif">
                    <div>
                    <p>
                    That's important - it tests for set membership,
                    it doesn't store any data.
                    </p>
                    <p>
                    It can tell you if something is in a set,
                    but you can't retrieve an item
                    from the set.
                    </p>
                </div>
                </section>
                <section data-background="images/67.gif">
                    <div>
                    <p>
                    Like, if we have three objects - banana, apple, and bowling ball.
                    </p>
                </div>
                </section>
                <section data-background="images/68.gif">
                    <div>
                    <p>
                    And a bloom filter, representing the set of 'fruit'.
                    </p>
                </div>
                </section>
                <section data-background="images/69.gif">
                    <div>
                    <p>
                    We can use the set to determine that banana and apple are probably 'fruit', and 'bowling ball' is not.
                    </p>
                </div>
                </section>
                <section data-background="images/69b.gif">
                    <div>
                    <p>
                    But we can't give you a list of all of the fruit that were
                    used to populate the set.
                    </p>
                    <p> We don't know them. </p>
                </div>
                </section>
                <section data-background="images/70.gif">
                    <div>
                    <p>
                    So, a lot of the time, Bloom Filters are used to answer questions like
                    </p>
                    <p>
                    Is "chumpys" a real word?
                    </p>
                    <p>
                    No. No it is not.
                    </p>
                </div>
                </section>
                <section data-background="images/71.gif">
                    <div>
                        <p>
                        Is evil.ru a malicious website?
                        </p>
                        <p>
                        I don't know.
                        </p>
                    </div>
                </section>
                <section data-background="images/72.gif">
                    <div>
                        <p>
                        Is main.css in the cache?
                        </p>
                        <p>
                        Yes. Yes it is.
                        </p>
                    </div>
                </section>
                <section data-background="images/72b.gif">
                    <div>
                        <p>
                        Is this a banned image?
                        </p>
                    </div>
                </section>
                <section data-background="images/72c.gif">
                    <div>
                    <p>
                    Okay, let's look at this image problem a little bit.
                    </p>
                    <p>
                    Let's imagine we're running a forum and our itinerant
                    users keep posting banned images.
                    </p>
                    <p>
                    How do we know, looking at image data, if an image has
                    been banned?
                    </p>
                </div>
                </section>
                <section data-background="images/76.gif">
                    <div>
                    <p>
                    let's say we run a hash function on the target image,
                    </p>
                    <p>
                    yes, you can hash images - you can hash most anything
                    </p>
                </div>
                </section>
                <section data-background="images/77.gif">
                    <div>
                    <p>
                    mod the result by the length of an array
                    </p>
                </div>
                </section>
                <section data-background="images/78.gif">
                    <div>
                    <p style="margin-bottom:100px">
                    move to that index location in the array
                    </p>
                </div>
                </section>
                <section data-background="images/79.gif">
                    <div>
                    <p>
                    and save a link to the image there.
                    </p>
                    <p>
                    Then, when we're checking a new image, we can hash it,
                    and then check to see if it's in our array.
                    </p>
                </div>
                </section>
                <section data-background="images/83.gif">
                    <div>
                    <p>
                    of course, this is just a bog-standard hash table,
                    and I'm supposed to be talking about Bloom Filters
                    </p>
                    <p>
                    this works fine, but it takes up a lot of space
                    </p>
                    <p>
                    and I promised you space efficiency
                    </p>
                </div>
                </section>
                <section data-background="images/72c.gif">
                    <div>
                    <p>
                        Let's imagine there are 5000 images we want to
                        keep out of our forums and they take up 100 kilobytes each.
                    </p>
                    <p>
                        That means about a 500 megabyte table of banned images.
                        While it's not a tonne of space, it's enough that
                        you probably won't want to keep the whole thing
                        in RAM.
                    </p>

                </div>
                </section>
                <section data-background="images/79.gif">
                    <div>
                    <p>
                    remember, though, that we don't need storage from our
                    data structure</p>
                    <p>
                    we're only interested in whether or not this image <em>exists</em>
                    </p>
                </div>
                </section>
                <section data-background="images/84.gif">
                    <div>
                    <p style="margin-bottom:100px">
                    let's imagine that we store zeroes in every space in our
                    table
                    </p>
                </div>
                </section>
                <section data-background="images/85.gif">
                    <div>
                    <p style="margin-bottom: 100px">
                    and we store ones where our hash functions land.
                    </p>
                </div>
                </section>
                <section data-background="images/86.gif">
                    <div>
                    <p>
                    that way, we can check if an image is banned
                    </p>
                </div>
                </section>
                <section data-background="images/87.gif">
                    <div>
                    <p>
                    by hashing it, modding it
                    </p>
                </div>
                </section>
                <section data-background="images/88.gif">
                    <div>
                    <p>
                    and then checking if that spot in the array has
                    a 1 in it.
                    </p>
                </div>
                </section>
                <section data-background="images/89.gif">
                    <div>
                    <p>
                    if there's no 1 there, we can't possibly have
                    seen that image before.
                    </p>
                </div>
                </section>
                <section data-background="images/90.gif">
                    <div>
                    <p>
                    there's only one slight problem with this technique.
                    </p>
                    <p>
                    what happens when we have a different image that accidentally
                    collides with an image that we've set earlier?
                    </p>
                </div>
                </section>
                <section data-background="images/91.gif">
                    <div>
                    <p>
                    this creates a false positive, and unfairly takes
                    pictures of Nicholas Cage out of circulation
                    </p>
                </div>
                </section>

                <section data-background="images/blank.gif">
                    <div>
                    <p>
                    How do we stop collisions like this from occurring?
                    </p>
                    <p>
                    Well, we can use a hash function that guarantees an
                    astronomically low probability of collision.
                    </p>
                </div>
                </section>
                <section data-background="images/92.gif">
                    <div>
                    <p>
                    MD5, for example.
                    </p>
                    <p>
                    is a hash function that guarantees an
                    astronomically low probability of collision
                    </p>
                </div>
                </section>
                <section data-background="images/blank.gif">
                    <div>
                    <p>
                    But, with the astronomically low probability of collision,
                    you get, axiomatically, an astronomically high number of
                    potential outputs. With one bit for every output, you're
                    suddenly saddled with
                    </p>
                </div>
                </section>
                <section data-background="images/93.gif">
                    <div>
                    <p>
                    four times ten to the 25 terabytes, which is just a little
                    bit unrealistic to implement as a bit array.
                    </p>
                    <p>
                    Also way bigger than our original 500 megabyte estimate
                    for just storing these images in the first place.</p>
                </div>
                </section>
                <section data-background="images/94.gif">
                    <div>
                    <p> it does hit on one of the two strategies we can use
                    to reduce collisions, though </p>
                </div>
                </section>
                <section data-background="images/95.gif">
                    <div>
                    <p>
                    the obvious one: more space.
                    </p>
                    <p>
                    now let's look at the less obvious one:
                    </p>
                </div>
                </section>
                <section data-background="images/96.gif">
                    <div>
                    <p>
                    more hash functions.
                    </p>
                </div>
                </section>
                <section data-background="images/97.gif">
                    <div>
                    <p>
                    instead of hashing our image just once, let's hash it twice,
                    with two different hash functions
                    </p>
                </div>
                </section>
                <section data-background="images/98.gif">
                    <div>
                    <p>
                    this gives us two different locations in the table, and
                    we can store a one at both of them
                    </p>
                </div>
                </section>
                <section data-background="images/99.gif">
                    <div>
                    <p>
                    another image
                    </p>
                </div>
                </section>
                <section data-background="images/100.gif">
                    <div>
                    <p>
                    might share the result of one of
                    the hash functions
                    </p>
                </div>
                </section>
                <section data-background="images/101.gif">
                    <div>
                    <p>
                    but it's not as likely to share
                    the result of all of them
                    </p>
                    <p>
                    and if any of the hash functions point to a location
                    with a zero in it, we know that this object can never
                    have been entered into the Bloom Filter
                    </p>
                </div>
                </section>
                <section data-background="images/102.gif">
                    <div>
                    <p>
                    So, this is a bloom filter.
                    </p>
                    <p>
                    A bit field, and multiple hash functions to set the bits
                    in that field.
                    </p>
                    </div>
                </section>
                <section data-background="images/102.gif">
                    <div>
                    <p>
                    We put items in by hashing them multiple times and setting
                    the bits at all of those locations</p>
                    <p>
                    And we check if items are in the set by hashing items
                    multiple times
                    and checking if the bits are set at all of those locations.
                    </p>
                </div>
                </section>
                <section data-background="images/114.gif">
                    <div>
                    <p>
                    A lot of the time, Bloom Filters are paired up with other
                    data structures that handle the storage of the items.
                    </p>
                    <p>
                    For example, they are useful when paired with data structures
                    that exhibit worst-case performance
                    when searching for items that are not in the data-structure.
                    </p>
                </div>
                </section>
                <section data-background="images/114.gif">
                    <div>
                    <p>
                    In a linked list, or unsorted large array, for example, you
                    get the worst possible case performance when you're searching
                    for an item that just isn't there.
                    </p>
                    <p>
                    The bloom filter can check, before you hit the data structure,
                    if the data is actually <em>in</em> the data structure.
                    </p>
                </div>
                </section>
                <section data-background="images/115.gif">
                    <div>
                    <p>
                    they are also very useful
                    when the retrieval step for data takes a long time - for
                    example, when a network call needs to be made to a far
                    away database, a local bloom filter is a wonderfully
                    fast way to know if you are wasting everybody's time with
                    a request for something that doesn't exist.
                    </p>
                </div>
                </section>
                <section data-background="images/116.gif">
                    <div>
                    <p style="margin-top:150px">
                    or, data with a very low hit rate - if you're dealing
                    with the sort of data where most of the time, there's
                    no data to be found at all, you can catch all of those misses
                    with a bloom filter.
                    </p>
                </div>
                </section>
                <section data-background="images/blank.gif">
                    <div>
                    <p>
                    There are some downsides to this.
                    </p>
                </div>
                </section>
                <section data-background="images/overlap.gif">
                    <div>
                    <p>
                    Because each item we put in to the Bloom Filter
                    has multiple hash functions, and there can be
                    some overlap, we can never delete anything from
                    the Bloom Filter
                    </p>
                </div>
                </section>
                <section data-background="images/overlap_2.gif">
                    <div>
                    <p>
                    if we do
                    </p>
                </div>
                </section>
                <section data-background="images/overlap_2.gif">
                    <div>
                    <p>
                    we run the risk
                    of accidentally deleting something else from the filter.
                    </p>
                </div>
                </section>
                <section data-background="images/false_positive.gif">
                    <div>
                    <p>
                    on top of that, we've reduced the chance of collisions,
                    but it's impractical to reduce that chance to effectively
                    zero, so there's always some chance of a false positive.
                    </p>
                    <p>
                    however, this probability is at least a number that we
                    have control over
                    </p>
                </div>
                </section>
                <section data-background="images/106.gif">
                    <div>
                    <p>
                    if we know the desired probability of a collision
                    </p>
                </div>
                </section>
                <section data-background="images/107.gif">
                    <div>
                    <p>
                     - in the case of our image filter, let's say 0.1%.
                    </p>
                </div>
                </section>
                <section data-background="images/108.gif">
                    <div>
                    <p>
                    and the number of things we want to put in the filter
                    </p>
                </div>
                </section>
                <section data-background="images/109.gif">
                    <div>
                    <p>
                     as we mentioned before, about 5000 images
                    </p>
                </div>
                </section>
                <section data-background="images/111.gif">
                    <div>
                    <p>
                    we can use handwavy math to determine
                    how much space we need
                    </p>
                    <p>
                    and how many hash functions we need to get an optimal solution
                    </p>
                    <p> you don't need to look too closely, it's quite
                    easy to find these functions online </p>
                </div>
                </section>
                <section data-background="images/112.gif">
                    <div>
                    <p>
                    so, doing this math with our numbers,
                    we need an array of 71,888 bits - 8.8 kilobytes
                    </p>
                    <p>
                    that's small enough that we could keep it in RAM - heck
                    we could send that bloom filter to the user and run
                    it client-side. It's certainly easier to work with
                    than 500 megabytes of image.</p>
                </div>
                </section>
                <section data-background="images/113.gif">
                    <div>
                    <p>
                    and 10 different hash functions -
                    </p>
                    <p>
                    that is to say, the optimal packing of this data
                    requires that each item we place in the table
                    set 10 different bits in the bloom filter
                    </p>
                </div>
                </section>
                <section data-background="images/cat_balloon.gif">
                    <div>
                    <p>
                    So, in summary, Bloom Filters are fast, compressed data structures used to
                    check for set membership, implemented as a set of hash functions pointing
                    to locations in a bit array. It doesn't allow for retrieval or removal.
                    </p>
                </section>

                <section data-background="images/121.gif" data-background-transition="slide">
                    <div>
                    <p>
                    Let's talk about how to pick which hash functions to use.
                    </p>
                </div>
                </section>
                <section data-background="images/122.gif">
                    <div>
                    <p>
                    I mean, I showed you my awesome cheesehash function earlier, but
                    its terrible, and on top of that it only really works on
                    strings.
                    </p>
                </div>
                </section>
                <section data-background="images/123-2.png">
                    <div>
                    <p>
                    There are many, many different Hash Functions.
                    </p>
                </div>
                </section>
                <section data-background="images/123-3.png">
                    <div>
                    <p>
                    only five of these are made-up
                    </p>
                </div>
                </section>
                <section data-background="images/124.gif">
                    <div>
                    <p>
                    So which ones do we pick for our data structures?
                    </p>
                </div>
                </section>
                <section data-background="images/125.gif">
                    <div>
                    <p>
                    well, for data-structures, the two properties we're
                    looking for in a hash are that the hash should
                    be fast, and well-distributed
                    </p>
                </div>
                </section>
                <section data-background="images/126.gif">
                    <div>
                    <p>
                    When we say 'fast', what we mean is 'non-cryptographic'.
                    </p>
                </div>
                </section>
                <section data-background="images/128.gif">
                    <div>
                    <p>
                    Cryptographic hashes are awesome. They have a bunch of
                    properties that make them totally bad-ass for security
                    functionality.
                    </p>
                </div>
                </section>
                <section data-background="images/129.gif">
                    <div>
                    <p>
                    The most important one being that they're "collision resistant" -
                    it's astronomically unlikely that you will be able to find
                    two different items that hash to the same value.
                    </p>
                </div>
                </section>
                <section data-background="images/130.gif">
                    <div>
                    <p>
                    But these cryptographic features also make them a lot more
                    processor-hungry.
                    </p>
                    <p>
                    So we should avoid hashes like SHA or MD5 when
                    we're working on data structure stuff, because we don't
                    need awesome security features in our Bloom Filter.
                    It's just a waste of CPU cycles.
                    </p>
                </div>
                </section>
                <section data-background="images/126.gif">
                    <div>
                    <p>So, non-cryptographic.</p>
                </div>
                </section>
                <section data-background="images/131.gif">
                    <div>
                    <p>
                    And well-distributed, which means that no matter how
                    similar your data <em>is</em> going in to the hash function,
                    </p>
                </div>
                </section>
                <section data-background="images/132.gif">
                    <div>
                    <p>
                    the
                    output appears all over the spectrum.
                    </p>
                </div>
                </section>
                <section data-background="images/133.gif">
                    <div>
                    <p> Hash functions that exhibit this quality are known
                    as 'avalanching' hashes
                    </p>
                </div>
                </section>
                <section data-background="images/134.gif">
                    <div>
                    <p>
                    because small changes in the input
                    </p>
                </div>
                </section>
                <section data-background="images/135.gif">
                    <div>
                    <p>
                    lead to large changes in the output.
                    </p>
                    <p>
                    Of course, this is also a desirable property in
                    cryptographic hashes, but this one we're willing to blow
                    our precious processor time on, because it's really important
                    for data structures that depend on hash functions to have
                    well-distributed hash functions.
                    </p>
                </div>
                </section>
                <section data-background="images/136.gif">
                    <div>
                    <p>
                    A common hash used for this purpose is the
                    non-cryptographic, well-avalanching,
                    public domain Murmur3 - implementations of which exist
                    for most modern languages
                    </p>
                </div>
                </section>
                <section data-background="images/137.gif">
                    <div>
                    <p>
                    - and which has appeared in numerous open-source products, including Hadoop,
                    Cassandra, and nginx.
                    </p>
                </div>
                </section>
                <section data-background="images/138.gif">
                    <div>
                    <p>
                    It also takes a seed value, so you can create dozens of different hash functions
                    out of Murmur3
                    </p>
                </div>
                </section>
                <section data-background="images/139.gif">
                    <div>
                    <p>
                    just by changing the seed value.
                    </p>
                </div>
                </section>

                <section data-background="images/blank.gif">
                    <div>
                    <p>
                    There are some reasons, though, that you might want cryptographic
                    hashes in your data structures -
                    </p>
                    </div>
                </section>
                <section data-background="images/hash_ddos.gif">
                    <div>
                    <p>
                    a clever attacker might take advantage of your data structure
                    and only insert data that matches a certain small set of
                    hashes, forcing collision after collision until your whole
                    application falls over!
                    </p>
                    </div>
                </section>

                <section data-background="images/siphash.gif">
                    <div>
                    <p>
                    So, for some languages, Python after 3.4, for example, the default hash function
                    provided by the language is actually a cryptographic hash.
                    </p>
                    </div>
                </section>

                <section data-background="images/80.gif">
                    <div>
                    <p>
                    One other thing - we hashed an image to put in our
                    data structure, earlier.
                    </p>
                    <p>
                    What sort of hash function works on an image?
                    </p>
                </div>
                </section>
                <section data-background="images/142.gif">
                    <div>
                    <p>
                    Well, most of them, really, but a perceptual hash, or
                    pHash, is designed specifically to cluster very similar
                    images together in the hash output.
                    </p>
                    </div>
                </section>
                <section data-background="images/142.gif">
                    <div>
                    <p>
                    For example, if it's the same image, but sized larger,
                    or skewed to the left, it should end up with a hash
                    location very close to or identical to the hash location
                    of the original image.
                    </p>
                </div>
                </section>
                <section data-background="images/142.gif">
                    <div>
                    <p>
                    Of course, by nature, this hash function won't be
                    distributed in the way that we would need for
                    an optimal general-purpose data structure
                    </p>
                    <p>
                    It's the opposite of an 'avalanching' hash - small changes
                    in the input lead to almost no changes in the output.
                    </p>
                    </div>
                </section>
                <section data-background="images/142.gif">
                    <div>
                    <p>
                    But we can abuse that property so that false positives are
                    unfairly clustered on images that look very similar to
                    our banned images.
                    Which would actually probably be a good thing.
                    </p>
                </div>
                </section>
                <section data-background="images/144.gif" data-background-transition="slide">
                    <div>
                    <p>
                    Okay, so, that concludes the data-structures portion of
                    the presentation.
                    </p>
                    <p>
                    Now, let's talk about how hash functions contribute to
                    the security of your application.
                    </p>
                </div>
                </section>
                <section data-background="images/145.gif">
                    <div>
                    <p>
                    Okay, you're running a web application, and the worst-case
                    scenario happens.
                    </p>
                    <p>
                    Some hacker makes off with the user
                    table from your database.
                    </p>
                    <p>
                    "How"?
                    </p>
                </div>
                </section>
                <section data-background="images/145.gif">
                    <div>

                    <p>
                    I don't know, for the sake of argument let's say
                    SQL Injection.
                    </p>
                    <p>
                    At this point your users are all shit out of luck, right?
                    </p>
                    <p>
                    I mean, some brigand has made off with all of their
                    passwords.
                    </p>
                </div>
                </section>
                <section data-background="images/146.gif">
                    <div>
                    <p>
                    But no, because our developers have cleverly obscured
                    the passwords before saving them.
                    </p>
                    <p>
                    Hopefully you're already aware of this.
                    </p>
                </div>
                </section>
                <section data-background="images/147.gif">
                    <div>
                    <p>
                    So, in order to hide passwords this way, when the
                    user creates a password, we don't save the password.
                    </p>
                </div>
                </section>
                <section data-background="images/147b.gif">
                    <div>
                    <p>
                    Instead, we save the result of a hash function.
                    </p>
                </div>
                </section>
                <section data-background="images/148.gif">
                    <div>
                    <p>
                    Later, when the user tries to log in, they provide a
                    password. We hash the password, and compare it with
                    our hashed password for that user.
                    </p>
                </div>
                </section>
                <section data-background="images/148b.gif">
                    <div>
                    <p>
                    If the two match,
                    the user has provided the correct password.
                    </p>
                </div>
                </section>
                <section data-background="images/149.gif">
                    <div>
                    <p>
                    Of course, if two different passwords ever collide -
                    if two strings hash to the same output value -
                    then it would be possible for someone to log in to
                    our site with the wrong password. That's bad.
                    </p>
                </div>
                </section>
                <section data-background="images/128.gif">
                    <div>
                    <p>
                    Do you remember earlier when I said that cryptographic
                    hashes - like MD5, for example -
                    have a feature called collision resistance, which
                    means that two inputs are astronomically unlikely to
                    collide? Here is where that's super important.
                    </p>
                </div>
                </section>
                <section data-background="images/blank.gif">
                    <div>
                    <p>
                    Now, our passwords are protected.
                    </p>
                    <p>
                    Yup. Totally protected. Nothing could possibly go wrong.
                    </p>
                </div>
                </section>
                <section data-background="images/150.gif">
                    <div>
                    <p>
                    Okay, let's talk about
                    Dictionary Attacks, the Way To Break Hashed Passwords
                    </p>
                </div>
                </section>
                <section data-background="images/151.gif">
                    <div>
                    <p>
                    So, we've stolen a whole database full of usernames
                    and hashed passwords, and we want to get at the raw
                    passwords so that we can try them out on banking sites
                    and such.
                    </p>
                </div>
                </section>
                <section data-background="images/152.gif">
                    <div>
                    <p>
                    What we can do, is create a list of everything that we
                    think of as a possible password. An enormous, comprehensive
                    list.
                    </p>
                </div>
                </section>
                <section data-background="images/153.gif">
                    <div>
                    <p>
                    Then, we use the same hash that the programmer used to
                    hash the original passwords,
                    and we run that on every single item in our gigantic
                    password list.
                    </p>
                </div>
                </section>
                <section data-background="images/154.gif">
                    <div>
                    <p>
                    Now we have a giant collection of hash-to-password pairs,
                    which we can compare against the original data.
                    </p>
                </div>
                </section>
                <section data-background="images/155.gif">
                    <div>
                    <p>
                    Any time we find a match with one of the hashes in our
                    set, we know what the password must have been.
                    </p>
                    <p>
                    This checking of every hash in the set against every
                    hash in the database is n-squared,
                    but inherently very parallelizable, so
                    with a bit of optimization this can run VERY fast.
                    </p>
                </div>
                </section>
                <section data-background="images/155.gif">
                    <div>
                    <p>
                    This is called a precomputed dictionary attack.
                    </p>
                    <p>
                    Precomputed dictionary attacks are common, and extremely powerful.
                    </p>
                </div>
                </section>
                <section data-background="images/157.gif">
                    <div>
                    <p>
                    The MD5 hash function is so common that Juuso Salonen
                    released a utility called Bozocrack
                    that works by taking a hashed password,
                    searching for it on Google,
                    and then MD5-hashing everything that comes back in the
                    google results until it finds a match.
                    </p>
                    </div>
                </section>
                <section data-background="images/157.gif">
                    <div>
                    <p>
                    It's not as comprehensive as a MD5 Dictionary, but
                    it still manages to be depressingly effective.
                    </p>
                </div>
                </section>
                <section data-background="images/157b.gif">
                    <div>
                    <p>
                    Part of the reason these attacks are so effective
                    is that, because every user's password has been hashed
                    with the same hash function, it's possible for us to
                    test passwords against the entire table.
                    While it is unlikely that we will ever crack all of the
                    passwords, we're able to suss out the users who have
                    simple passwords very quickly.
                    </p>
                    </div>
                </section>

                <section data-background="images/157b.gif">
                    <div>
                    <p>
                    Just testing the whole database against the 1000 most
                    common passwords shouldn't take more than an hour,
                    and will provide us with a wealth of potentially
                    useful data.
                    </p>
                </div>
                </section>
                <section data-background="images/159.gif">
                    <div>
                    <p>
                    So what we want to do is reduce the effectiveness
                    of this kind of attack, by using a different hash
                    function for every single person in the database.
                    </p>
                </div>
                </section>
                <section data-background="images/160.gif">
                    <div>
                    <p>
                    That doesn't mean we need to enlist thousands
                    of different hash implementations -
                    what it <em>actually</em> means is that we want to use one
                    hash function that we seed with a different value
                    for each user in the table, before we hash the
                    password for that user.
                    </p>
                    </div>
                </section>
                <section data-background="images/160.gif">
                    <div>
                    <p>
                    It has to be a value that we have access to -
                    because we need to be able to recreate this custom
                    hash function every time we check the user's password.
                    </p>
                    <p>
                    It's quite common to use the username for this value.
                    </p>
                </div>
                </section>
                <section data-background="images/161.gif">
                    <div>
                    <p>
                    That doesn't mean you <em>should</em> use the username.
                    </p>
                    <p>
                    Cryptographers recommend that you create a large block
                    of randomized data and save it against the user to
                    use as a seed.
                    </p>
                </div>
                </section>
                <section data-background="images/158b.gif">
                    <div>
                    <p>
                    This hash-seeding value is called a salt.
                    </p>
                </div>
                </section>
                <section data-background="images/158c.gif"></section>
                <section data-background="images/162.gif">
                    <div>
                    <p>
                    Okay, so that covers the basics.
                    </p>
                    <p>
                    And when I say basics I mean very most basics.
                    This isn't exactly state of the art.
                    Unix's 'crypt' function first used salted hashes to
                    protect against dictionary attacks in 1976,
                    a full decade before I was born.
                    </p>
                </div>
                </section>
                <section data-background="images/163.gif">
                    <div>
                    <p> Okay, the next thing to talk about is not using MD5. Let's talk about that. </p>                    <p>
                    <p>
                    MD5 is well-known, and well-understood, and it's been
                    in use for a good long time.
                    </p>
                    <p>
                    Unfortunately, in that good long time, cracks have
                    begun to show in this venerable hashing algorithm.
                    </p>
                </div>
                </section>
                <section data-background="images/brute_force.gif">
                    <div>
                    <p>
                    The biggest reason to avoid MD5 is simply that it is
                    too fast.
                    </p>
                    <p>
                    It's possible to MD5 hash millions of values per second on a modern CPU.
                    </p>
                </div>
                </section>
                <section data-background="images/brute_force.gif">
                    <div>
                    <p>
                    Of course, when it comes down to making lots of parallizable computations
                    very quickly, there's modern graphics hardware, which can compute trillions
                    of hashes per second. Some people involved in Bitcoin mining - and Bitcoin
                    mining is also about calculating hashes very quickly - are custom-making
                    hardware that can perform quadrillions of hashes per second.
                    </p>
                </div>
                </section>
                <section data-background="images/brute_force.gif">
                    <div>
                    <p>
                    This makes brute force attacks against MD5-hashed passwords
                    very easy, even if they are salted.
                    </p>
                </div>
                </section>
                <section data-background="images/164.gif">
                    <div>
                    <p>
                    This MD5-hashing python script I wrote runs, on a cheap
                    little virtual machine, one million MD5 hashes in
                    1.5 seconds.
                    </p>
                    </div>
                </section>
                <section data-background="images/165.gif">
                    <div>
                    <p>
                    Now, BCrypt is designed to be slow. Using the default settings
                    on the same virtual machine, that run would take me 3.4 days.
                    </p>
                    <p>
                    This, combined with a salt for each individual user, means
                    that brute forcing passwords out of a database could take
                    days or months per user, rather than an hour or two for
                    the whole thing.
                    </p>
                </div>
                </section>
                <section data-background="images/166.gif">
                    <div>
                    <p>
                    BCrypt also comes with a work variable that you can crank
                    up to make things even slower as hardware gets faster.
                    When I turn it up to 15, my million-hash script goes from
                    3.4 days to run, to 26 days to run.
                    </p>
                    <p>
                    At this point, though, just logging
                    a single user in to my site could take a couple of seconds.
                    I'm not sure if they're willing to wait that long.
                    </p>
                </div>
                </section>
                <section data-background="images/167.gif">
                    <div>
                    <p>
                    So, for password security, you should use something
                    that's specifically designed for password security -
                    like Bcrypt, or PBKDF2
                    </p>
                    </div>
                </section>
                <section data-background="images/sha.gif">
                    <div>
                    <p>
                    But even for general purposes - this is, everything else
                    that you might want a cryptographic hash for, but not passwords -
                    if you're looking for
                    a secure hash algorithm, MD5 is kind of old and broken.
                    </p>
                </div>
                </section>
                <section data-background="images/sha.gif">
                    <div>
                    <p>
                    SHA means "Secure Hash Algorithm", and SHA-512
                    has become a new standard for hashing, one that's
                    cryptographically much more secure.
                    </p>
                </div>
                </section>

                <section data-background="images/170.gif">
                    <div>
                    <p>
                    So, listening to this, you might be thinking -
                    why send the password to the server-side at all?
                    </p>
                </div>
                </section>
                <section data-background="images/171.gif">
                    <div>
                    <p>
                    The user could just hash their own password and send
                    the hashed password to the server for verification.
                    </p>
                    <p>
                    Heck, we could go totally stateless - we could
                    start including a hashed verification
                    code with every instruction we send to the server.
                    </p>
                    <p>
                    That way, nobody can tamper with our instructions
                    to the server!
                    </p>
                </div>
                </section>
                <section data-background="images/172.gif">
                    <div>
                    <p>
                    Well, there are two different possibilities, here.
                    </p>
                    <p>
                    Either we're trying this from a browser,
                    or we're not trying this from a browser.
                    </p>
                </div>
                </section>
                <section data-background="images/173.gif">
                    <div>
                    <p>
                    Let's look at the problems of doing this
                    with browser code.
                    </p>
                </div>
                </section>
                <section data-background="images/174.gif">
                    <div>
                    <p>
                    What are we trying to accomplish, here?
                    </p>
                    <p>
                    We don't want people who can inspect our
                    traffic to see a password.
                    </p>
                    <p>
                    We don't want people who can inspect our
                    traffic to be able to act on behalf
                    of our users.
                    </p>
                    <p>
                    So we send our users a bit of code that
                    will allow them to obscure their credentials
                    when they communicate with us.
                    </p>
                </div>
                </section>
                <section data-background="images/175.gif">
                    <div>
                    <p>
                    Except if people can inspect our traffic,
                    they can also alter our traffic.
                    </p>
                    <p>
                    Which means they can replace our crypto code
                    with equivalent code that steals credentials.
                    </p>
                    <p>
                    Javascript browser crypto is exactly as
                    secure as the transport layer providing it.
                    </p>
                </div>
                </section>
                <section data-background="images/176.gif">
                    <div>
                    <p>
                    So Javascript browser crypto over HTTP
                    can't possibly be more secure than just
                    using HTTP - which is not secure at all.
                    </p>
                    <p>
                    And Javascript browser crypto over HTTPS is
                    as secure as just using TLS,
                    which is ... more or less secure.
                    </p>
                    <p> But you can't make it more secure by improving the javascript
                    because as soon as somebody breaks the TLS, the can change the javascript.</p>
                </div>
                </section>
                <section data-background="images/177.gif">
                    <div>
                    <p>
                    Let's imagine, then, that we're not doing this
                    from the browser, but from a trusted library
                    that we have total control over,
                    and we still want to keep bad people away from user data
                    and out of our application.
                    </p>
                </div>
                </section>
                <section data-background="images/178.gif">
                    <div>
                    <p>
                    Well, if we just send a token containing a hash
                    of our password, all the bad people have to do is steal that
                    token and they can start running dictionary attacks on
                    it. Plus, with our token they can still pretend \
                    to be our user pretty effectively. That's bad.
                    </p>
                </div>
                </section>
                <section data-background="images/179.gif">
                    <div>
                    <p>
                    So, what we need to do is hash the password and a
                    timestamp together.
                    </p>
                    <p>
                    Then the server can... no... that won't work.
                    </p>
                    <p>
                    Couldn't the attacker just steal our timestamped message
                    and replace the command with their own, malicious
                    command?
                    </p>
                </div>
                </section>
                <section data-background="images/180.gif">
                    <div>
                    <p>
                    This gets really complicated, really fast, and
                    it is SO easy to do it wrong.
                    </p>
                    <p>
                    We shouldn't be in the business of designing our
                    own security algorithms.
                    </p>
                    <p>
                    The hash function is a building block, but we
                    need more guidance when it comes to problems
                    like this.
                    </p>
                </div>
                </section>
                <section data-background="images/do_not_touch.gif">
                    <div>
                    <p>
                    But that guidance shouldn't come from me.
                    When it comes to serious cryptographic protocol implementation, it's
                    time to call in bigger guns.
                    </p>
                    </div>
                </section>

                <section data-background="images/toc.gif">
                </section>
                <section data-background="images/nameplate_cubedrone.gif">
                </section>
			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: 'none', // default/cube/page/concave/zoom/linear/fade/none

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
				]
			});

		</script>

	</body>
</html>
